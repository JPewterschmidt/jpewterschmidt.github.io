---
layout: post
title: 模板简述
---

本文是作者一时兴起，决定备份一下之前做的笔记而写。有什么不严谨的，不准确的表述还劳烦读者指出。

## 模板是什么

本人对模板建立的第一印象是通过STL中的各种容器，所以理所当然地认为C++模板就是泛型。
但实际上不完全是泛型。除了泛型，C++模板还是一种元编程手段，即程序员指导编译器生成代码的手段。

### 关于泛型

很多代码唯一的差别就是对操作对象，面对不断新增的对象类型，这些代码要么一次次重写，
要么用类型擦除。后者会使代码方式类型系统的优势，使得系统难以维护。
所以应该使用泛型。
目前泛型有两种主要实现方式，分别是C++模板这种类似于token直接替换的泛型，
还有一种就以java为代表的基于`Object`基类的泛型。后者在我个人看来更多的是某种语法糖，
在程序员视角代码中类型是`T`等泛型的姿态体现，而在实际运行过程中却与`Object`无二。

### 关于元编程

本人是通过对泛型的进一步使用逐步了解的元编程。
主要是通过某些容器场景，根据不同类型的不同特性可作出系列优化。
比如，为了实现强异常安全，如果容器的元素类型没有`noexcept`移动构造，
那么移动整个容器的时候就得一个一个复制元素，还要有系列fallback逻辑，来保证强异常安全。
反之，容器就可以放心地移动元素。后者相对于前者是一个很大的性能优化，其逻辑也是不同的。
根据类型特点生成或者说选用不同的代码，我认为这就叫做元编程。

此外，模板元编程不光支持以类型作参数。还支持整数字面量等其他字面量做参数，有关讨论见后文。

## 模板函数

### 模板实参推导

模板实参推导(Template Argument Deduction)可以免去在调用模板函数时显示指定模板实际参

```c++
template<typename T> void func(T t)
{
    //...
}

func(1);   // T: int
func(1.0); // T: double
```

#### 推导中的类型转换

但在设计模板函数实参类型转换，规则和非模板函数不同：
- 若按引用声明形参，则不进行任何转换（就算是 trivial 的转换都不行），两个参数的类型必须一致。
- 若按值声明行惨，则只有 trivial 转换是允许的。`const` 和 `volatile` 会被忽略。

```c++
template<typename T>
auto func1(const T& a, const T& b)
{
    return *a < *b;
}

template<typename T>
auto func2(T a, T b)
{
    return *a < *b;
}

char s1[] = "abcdef";
char a = 'a';
func1(&a, s1); // Error, &a: char* s1: char[7], not matched.
func2(&a, s1); // OK, s1 decay 成一个 char* 
```

